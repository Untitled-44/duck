


__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________ARM_____________________________________________
__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________



4.3 Branch and Exchange (BX):
cccc 0001 0010 1111 1111 1111 0001 nnnn
first bit of rn determines how to decode the subsequent instructions after the branch

4.4 Branch and Branch with Link (B, BL):
cccc 101L oooo oooo oooo oooo oooo oooo
like the branch, except the offset (sign-extended, 2s complement) is added to the pc.
the link bit determines if the old address is saved in the link register R14, allowing for "function" calls

4.13 Software Interrupt (SWI)
used for calls to the operating system, enters supervisor mode(SVC) in ARM state
cccc 1111 xxxx xxxx xxxx xxxx xxxx xxxx
bottom 24 bits ignored by processor

4.17 Undefined Instruction (undefined)
cccc 011x xxxx xxxx xxxx xxx1 xxxx
there is no assembler mnemonic for this, so i guess reserved for future use? 

4.5 Data Processing (ALU) (AND, EOR, SUB, RSB, ADD, ADC, SBC, RSC, TST, TEQ, CMP, CMN, ORR, MOV, BIC, MVN):
cccc 00Io oooS nnnn dddd 2222 2222 2222 (general format)
the I bit changes the format of operand 2 (the 12 ending bits)
the 4 bit opcode after the I bit changes the function of the instruction

if I bit is 0, then operand 2 will be composed of a 8 bit shift, and 4 bits for register. these 8 bits are further composed of either...
-5 bit imm, 2 bit shift type, and a 0
-4 bit regnum, 0, 2 bit shift type, and a 1 (bottom byte of register used to shift the register)
if I bit is 1, then operand 2 will be composed of a 4 bit shift, and 8 bit imm

in otherwords, either shift 8 bit imm with 4 bits, or shift a register with 5 bit imm with more control, or with register's bottom byte with more control
the resulting number is then used with operand 1, nnnn, with an operation dictated by the opcode
e.g. nnnn AND mmmm mmmm with 4 bit shift

thus, all possible instructions are
I bit set to 1 (4 bit shift 8 bit imm) ...
cccc 0010 000S nnnn dddd ssss mmmm mmmm //AND and
cccc 0010 001S nnnn dddd ssss mmmm mmmm //EOR exclusive or
cccc 0010 010S nnnn dddd ssss mmmm mmmm //SUB subtract
cccc 0010 011S nnnn dddd ssss mmmm mmmm //RSB reverse subtract
cccc 0010 100S nnnn dddd ssss mmmm mmmm //ADD addition
cccc 0010 101S nnnn dddd ssss mmmm mmmm //ADC add with carry
cccc 0010 110S nnnn dddd ssss mmmm mmmm //SBC subtract with carry
cccc 0010 111S nnnn dddd ssss mmmm mmmm //RSC reverse subtract with carry
cccc 0011 0001 nnnn dddd ssss mmmm mmmm //TST test bits (dddd is either all 0s or 1s)
cccc 0011 0011 nnnn dddd ssss mmmm mmmm //TEQ test bitwise equality (dddd is either all 0s or 1s)
cccc 0011 0101 nnnn dddd ssss mmmm mmmm //CMP compare (dddd is either all 0s or 1s)
cccc 0011 0111 nnnn dddd ssss mmmm mmmm //CMN compare negative (dddd is either all 0s or 1s)
cccc 0011 100S nnnn dddd ssss mmmm mmmm //ORR or
cccc 0011 101S 0000 dddd ssss mmmm mmmm //MOV move register or constant
cccc 0011 110S nnnn dddd ssss mmmm mmmm //BIC bit clear
cccc 0011 111S 0000 dddd ssss mmmm mmmm //MVN move negative register

I bit set to 0 (5 bit shift register mmmm by shift type tt)
cccc 0000 000S nnnn dddd ssss stt0 mmmm //AND and
cccc 0000 001S nnnn dddd ssss stt0 mmmm //EOR exclusive or
cccc 0000 010S nnnn dddd ssss stt0 mmmm //SUB subtract
cccc 0000 011S nnnn dddd ssss stt0 mmmm //RSB reverse subtract
cccc 0000 100S nnnn dddd ssss stt0 mmmm //ADD addition
cccc 0000 101S nnnn dddd ssss stt0 mmmm //ADC add with carry
cccc 0000 110S nnnn dddd ssss stt0 mmmm //SBC subtract with carry
cccc 0000 111S nnnn dddd ssss stt0 mmmm //RSC reverse subtract with carry
cccc 0001 0001 nnnn dddd ssss stt0 mmmm //TST test bits (dddd is either all 0s or 1s)
cccc 0001 0011 nnnn dddd ssss stt0 mmmm //TEQ test bitwise equality (dddd is either all 0s or 1s)
cccc 0001 0101 nnnn dddd ssss stt0 mmmm //CMP compare (dddd is either all 0s or 1s)
cccc 0001 0111 nnnn dddd ssss stt0 mmmm //CMN compare negative (dddd is either all 0s or 1s)
cccc 0001 100S nnnn dddd ssss stt0 mmmm //ORR or
cccc 0001 101S 0000 dddd ssss stt0 mmmm //MOV move register or constant
cccc 0001 110S nnnn dddd ssss stt0 mmmm //BIC bit clear
cccc 0001 111S 0000 dddd ssss stt0 mmmm //MVN move negative register

I bit set to 0 (shift register mmmm by bottom byte in register ssss by shift type tt)
cccc 0000 000S nnnn dddd ssss 0tt1 mmmm //AND and
cccc 0000 001S nnnn dddd ssss 0tt1 mmmm //EOR exclusive or
cccc 0000 010S nnnn dddd ssss 0tt1 mmmm //SUB subtract
cccc 0000 011S nnnn dddd ssss 0tt1 mmmm //RSB reverse subtract
cccc 0000 100S nnnn dddd ssss 0tt1 mmmm //ADD addition
cccc 0000 101S nnnn dddd ssss 0tt1 mmmm //ADC add with carry
cccc 0000 110S nnnn dddd ssss 0tt1 mmmm //SBC subtract with carry
cccc 0000 111S nnnn dddd ssss 0tt1 mmmm //RSC reverse subtract with carry
cccc 0001 0001 nnnn dddd ssss 0tt1 mmmm //TST test bits (dddd is either all 0s or 1s)
cccc 0001 0011 nnnn dddd ssss 0tt1 mmmm //TEQ test bitwise equality (dddd is either all 0s or 1s)
cccc 0001 0101 nnnn dddd ssss 0tt1 mmmm //CMP compare (dddd is either all 0s or 1s)
cccc 0001 0111 nnnn dddd ssss 0tt1 mmmm //CMN compare negative (dddd is either all 0s or 1s)
cccc 0001 100S nnnn dddd ssss 0tt1 mmmm //ORR or
cccc 0001 101S 0000 dddd ssss 0tt1 mmmm //MOV move register or constant
cccc 0001 110S nnnn dddd ssss 0tt1 mmmm //BIC bit clear
cccc 0001 111S 0000 dddd ssss 0tt1 mmmm //MVN move negative register


4.5 Multiply and Multiply-Accumulate (MUL, MLA):
cccc 0000 00as dddd nnnn ssss 1001 mmmm
the four bytes before s are an opcode...
0000 -> a = 0 -> MUL
0001 -> a = 1 -> MLA
nnnn should be all 0 if MUL (rd = rs * rm, rn is not used)
otherwise, in MLA, nnnn can be whatever (rd = rs * rm + rn)
results in a 32 bit number

4.8 Multiply Long and Multiply-Accumulate Long (MULL, MLAL [with signed and unsigned versions i.e. UMULL, UMLAL, SMULL, SMLAL]):
cccc 0000 1uas hhhh llll ssss 1001 mmmm
again, the four bytes before s are an opcode...
0100 -> u = 0, a = 0, -> UMULL
0101 -> u = 0, a = 1, -> UMLAL
0110 -> u = 1, a = 0, -> SMULL
0111 -> u = 1, a = 1, -> SMLAL
results in a 64 bit number (a long, hence the L in the instructions)

4.6 PSR transfer (MRS, MSR)
-Move PSR status/flags to register (MRS)
-Move register to PSR status/flags (MSR)
fsxc controls which bits are written (s and x flags should never work, those bits in the PSR are reserved)
the p bit determines if its CPSR or SPRS_current_mode

MRS:
cccc 0001 0p00 1111 dddd 0000 0000 0000
MSR RM:
cccc 0001 0p10 fsxc 1111 0000 0000 mmmm
MSR IMM:
cccc 0011 0p10 fsxc 1111 ssss mmmm mmmm

4.9 Single Data Transfer (LDR - load register from mem, STR - store register to mem) 
cccc 01ip ubwl nnnn dddd oooo oooo oooo

cccc 01i0 ubt0 nnnn dddd oooo oooo oooo (STR - store to memory) writeback enabled
cccc 01i1 ubw0 nnnn dddd oooo oooo oooo writeback optional

cccc 01i0 ubt1 nnnn dddd oooo oooo oooo (LDR - load from memory) writeback enabled
cccc 01i1 ubwl nnnn dddd oooo oooo oooo writeback optional

4.10 Halfword and Signed Data Transfer  (LDRH/STRH/LDRSB/LDRSH)
load unsigned halfword / store halfword / load signed byte / load signed halfword
cccc 000p uiwl nnnn dddd xxxx xxxx xxxx

the l bit determines whether it is load or store
the two bits oo determine what kind of load / store (there is only one kind of store)
when i = 0, register offset is used (else 8 bit imm, 4 from either side of 1oo1)

p = 0 i = 0
cccc 0000 u00l nnnn dddd 0000 1oo1 mmmm
p = 0 i = 1
cccc 0000 u10l nnnn dddd mmmm 1oo1 mmmm
p = 1 i = 0
cccc 0001 u0wl nnnn dddd 0000 1oo1 mmmm
p = 1 i = 1
cccc 0001 u1wl nnnn dddd mmmm 1oo1 mmmm

4.11 Block Data Transfer (LDM, STM)
cccc 100p uswl nnnn rrrr rrrr rrrr rrrr

stores / loads a list of registers
if l bit is set, then LDM, else STM


4.12 Single Data Swap (SWP)
cccc 0001 0b00 nnnn dddd 0000 1001 mmmm

4.14 / 4.15 / 4.16 Coprocessor Instructions (MRC/MCR, LDC,STC, CDP)
MRC / MCR:
cccc 1110 oooa nnnn dddd pppp iii1 mmmm
LDC / STC:
cccc 110p unwo nnnn dddd pppp mmmm mmmm
CDP:
cccc 1110 oooo nnnn dddd pppp iii0 mmmm

these instructions are all ignored, no coprocessor exists in the GBA*


__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________THUMB_____________________________________________
__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________
THUMB INSTRUCTIONS ARE 16 BITS

THUMB.1: move shifted register
000o offf ffss sddd
equivalent in ARM is MOV instruction

THUMB.2: add/subtract
0001 1oon nnss sddd
equivalent in ARM is of course ADD/SUB instruction

THUMB.3: move/compare/add/subtract immediate
001o oddd nnnn nnnn
eqiuivalent in ARM is MOV/CMP/ADD/SUB

THUMB.4: ALU operations
0100 00oo ooss sddd
look at the doc for all opcode meanings

THUMB.5: Hi register operations/branch exchange
0100 01oo dsss sddd
unlike other instructions, this instruction can interact with hi (r8-15) registers

0100 0100 10ss sddd ADD, using rd as hi register
0100 0100 01ss sddd ADD, using rs as hi register
0100 0100 11ss sddd ADD, both registers are hi
0100 0101 10ss sddd CMP, using rd as hi register
0100 0101 01ss sddd CMP, using rs as hi register
0100 0101 11ss sddd CMP, both registers are hi
0100 0110 10ss sddd MOV, using rd as hi register
0100 0110 01ss sddd MOV, using rs as hi register
0100 0110 11ss sddd MOV, both registers are hi
0100 0111 0sss s000 BX, only uses rs

THUMB.6: load PC-relative (for loading immediates from literal pool)
0100 1ddd nnnn nnnn

loads register ddd with 4 byte word at pc + 8 bit imm nnnn nnnn.

THUMB.7: load/store with register offset
0101 oo0s ssbb bddd
s - offset register
b - base register
d - source/dest register
o - opcode

THUMB.8: load/store sign-extended byte/halfword (with register offset)
0101 oo1s ssbb bddd
same as above (different operations of course)

THUMB.9: load/store with imm offset
011o osss ssbb bddd
s - 5 bit offset (unsigned)

THUMB.10: load/store halfword (imm offset)
1000 osss ssbb bddd
same as above (but with half words instead of byte)

THUMB.11: load/store SP-relative
1001 oddd nnnn nnnn
like load pc-relative, except stackpointer is used (can also store instead of load based on opcode)

THUMB.12: get relative address
1010 oddd nnnn nnnn
stores pc (with bit 1 set to 0?) in rd, or sp in rd, with 8 bit imm (10 bit)

THUMB.13: add offset to stack pointer
1011 0000 onnn nnnn
increments/decrements sp by offset

THUMB.14: push/pop registers
1011 o10p rrrr rrrr
stores / loads a list of registers (p bit used for subroutines)
im assuming pushing / popping registers are done in reverse order
stack is descending (sp is decremented)

THUMB.15: multiple load/store
1100 obbb rrrr rrrr
same as above, except stores at mem addr in rb
however, looks like you increment (instead of decrement) rb after you store (and load!)
meaning the load is intended to be used with the original address used to store

THUMB.16: conditional branch
1101 oooo ssss ssss
conditionally branches with 8 bit offset from the pc (which will be +4 from prefetch)

THUMB.18: unconditional branch
1110 0sss ssss ssss
branches no matter what with 10 bit offset from the pc (again +4 like before with the other instructions)

THUMB.19: long branch with link
made up of two instructions (32 bits instead of 16 bits total)
first instruction
1111 0nnn nnnn nnnn
n - upper 11 bits of address
results in lr = pc + 4 + (nn << 12)
second instruction
1111 1nnn nnnn nnnn
results in pc = LR + (nn << 1), lr = (pc + 2) | 1
essentially, first instr loads upper 11 bits of addr in lr (shifted by 12 first for space for lower 11 bits), then 
the second addr loads the lower 11 bits of addr (shifted by one first, making it 12 bits, aligning it by halfword),
this result is then loaded into pc (pc branches by 23 bits) and lr is set to the address of the instruction after 
the second instruction — lr = (pc + 2) | 1. the or 1 is there to keep the cpu in THUMB mode

THUMB.17: software interrupt and breakpoint
1101 1111 nnnn nnnn
enters SVC mode and switches to ARM state, and saves next instr addr in lr and load SWI vector addr in pc
<<<<<<< HEAD
n - comment field for exception handler 





__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________
____________________________________________________________________________________ARM_PARSING___________________________________________________________
__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________
instructions here are grouped up by their first four bits (after the condition bits), and further sorted


[ 'cccc 0000 000S nnnn dddd ssss stt0 mmmm |AND and' ]
[ 'cccc 0000 001S nnnn dddd ssss stt0 mmmm |EOR exclusive or' ]
[ 'cccc 0000 010S nnnn dddd ssss stt0 mmmm |SUB subtract' ]
[ 'cccc 0000 011S nnnn dddd ssss stt0 mmmm |RSB reverse subtract' ]
[ 'cccc 0000 100S nnnn dddd ssss stt0 mmmm |ADD addition' ]
[ 'cccc 0000 101S nnnn dddd ssss stt0 mmmm |ADC add with carry' ]
[ 'cccc 0000 110S nnnn dddd ssss stt0 mmmm |SBC subtract with carry' ]
[ 'cccc 0000 111S nnnn dddd ssss stt0 mmmm |RSC reverse subtract with carry' ]
[ 'cccc 0000 000S nnnn dddd ssss 0tt1 mmmm |AND and' ]
[ 'cccc 0000 001S nnnn dddd ssss 0tt1 mmmm |EOR exclusive or' ]
[ 'cccc 0000 010S nnnn dddd ssss 0tt1 mmmm |SUB subtract' ]
[ 'cccc 0000 011S nnnn dddd ssss 0tt1 mmmm |RSB reverse subtract' ]
[ 'cccc 0000 100S nnnn dddd ssss 0tt1 mmmm |ADD addition' ]
[ 'cccc 0000 101S nnnn dddd ssss 0tt1 mmmm |ADC add with carry' ]
[ 'cccc 0000 110S nnnn dddd ssss 0tt1 mmmm |SBC subtract with carry' ]
[ 'cccc 0000 111S nnnn dddd ssss 0tt1 mmmm |RSC reverse subtract with carry' ]
[ 'cccc 0000 1uas hhhh llll ssss 1001 mmmm |MULTIPLY LONG AND MULTIPLY-ACCUMULATE LONG' ]
[ 'cccc 0000 00as dddd nnnn ssss 1001 mmmm |MULTIPLY AND MULTIPLY-ACCUMULATE' ]
[ 'cccc 0000 u000 nnnn dddd 0000 1011 mmmm |p=0 i=0 STRH' ]
[ 'cccc 0000 u101 nnnn dddd mmmm 1011 mmmm |p=0 i=1 LDRH' ]
[ 'cccc 0000 u100 nnnn dddd mmmm 1011 mmmm |p=0 i=1 STRH' ]
[ 'cccc 0000 u001 nnnn dddd 0000 1011 mmmm |p=0 i=0 LDRH' ]
[ 'cccc 0000 u001 nnnn dddd 0000 1101 mmmm |p=0 i=0 LDRSB' ]
[ 'cccc 0000 u101 nnnn dddd mmmm 1101 mmmm |p=0 i=1 LDRSB' ]
[ 'cccc 0000 u001 nnnn dddd 0000 1111 mmmm |p=0 i=0 LDRSH' ]
[ 'cccc 0000 u101 nnnn dddd mmmm 1111 mmmm |p=0 i=1 LDRSH' ]

[ 'cccc 0001 0p00 1111 dddd 0000 0000 0000 |MRS' ]
[ 'cccc 0001 0p10 fsxc 1111 0000 0000 mmmm |MSR register' ]
[ 'cccc 0001 110S nnnn dddd ssss stt0 mmmm |BIC bit clear' ]
[ 'cccc 0001 0101 nnnn dddd ssss stt0 mmmm |CMP compare (dddd is either all 0s or 1s)' ]
[ 'cccc 0001 0001 nnnn dddd ssss stt0 mmmm |TST test bits (dddd is either all 0s or 1s)' ]
[ 'cccc 0001 0111 nnnn dddd ssss stt0 mmmm |CMN compare negative (dddd is either all 0s or 1s)' ]
[ 'cccc 0001 101S 0000 dddd ssss stt0 mmmm |MOV move register or constant' ]
[ 'cccc 0001 0011 nnnn dddd ssss stt0 mmmm |TEQ test bitwise equality (dddd is either all 0s or 1s)' ]
[ 'cccc 0001 111S 0000 dddd ssss stt0 mmmm |MVN move negative register' ]
[ 'cccc 0001 100S nnnn dddd ssss stt0 mmmm |ORR or' ]
[ 'cccc 0001 0010 1111 1111 1111 0001 nnnn |BRANCH AND EXCHANGE' ]
[ 'cccc 0001 111S 0000 dddd ssss 0tt1 mmmm |MVN move negative register' ]
[ 'cccc 0001 0101 nnnn dddd ssss 0tt1 mmmm |CMP compare (dddd is either all 0s or 1s)' ]
[ 'cccc 0001 0111 nnnn dddd ssss 0tt1 mmmm |CMN compare negative (dddd is either all 0s or 1s)' ]
[ 'cccc 0001 0001 nnnn dddd ssss 0tt1 mmmm |TST test bits (dddd is either all 0s or 1s)' ]
[ 'cccc 0001 0011 nnnn dddd ssss 0tt1 mmmm |TEQ test bitwise equality (dddd is either all 0s or 1s)' ]
[ 'cccc 0001 100S nnnn dddd ssss 0tt1 mmmm |ORR or' ]
[ 'cccc 0001 110S nnnn dddd ssss 0tt1 mmmm |BIC bit clear' ]
[ 'cccc 0001 101S 0000 dddd ssss 0tt1 mmmm |MOV move register or constant' ]
[ 'cccc 0001 0b00 nnnn dddd 0000 1001 mmmm |SWP' ]
[ 'cccc 0001 u1w1 nnnn dddd mmmm 1011 mmmm |p=1 i=1 LDRH' ]
[ 'cccc 0001 u1w0 nnnn dddd mmmm 1011 mmmm |p=1 i=1 STRH' ]
[ 'cccc 0001 u0w0 nnnn dddd 0000 1011 mmmm |p=1 i=0 STRH' ]
[ 'cccc 0001 u0w1 nnnn dddd 0000 1011 mmmm |p=1 i=0 LDRH' ]
[ 'cccc 0001 u0w1 nnnn dddd 0000 1101 mmmm |p=1 i=0 LDRSB' ]
[ 'cccc 0001 u1w1 nnnn dddd mmmm 1101 mmmm |p=1 i=1 LDRSB' ]
[ 'cccc 0001 u1w1 nnnn dddd mmmm 1111 mmmm |p=1 i=1 LDRSH' ]
[ 'cccc 0001 u0w1 nnnn dddd 0000 1111 mmmm |p=1 i=0 LDRSH' ]

[ 'cccc 0010 000S nnnn dddd ssss mmmm mmmm |AND and' ]
[ 'cccc 0010 001S nnnn dddd ssss mmmm mmmm |EOR exclusive or' ]
[ 'cccc 0010 010S nnnn dddd ssss mmmm mmmm |SUB subtract' ]
[ 'cccc 0010 011S nnnn dddd ssss mmmm mmmm |RSB reverse subtract' ]
[ 'cccc 0010 100S nnnn dddd ssss mmmm mmmm |ADD addition' ]
[ 'cccc 0010 101S nnnn dddd ssss mmmm mmmm |ADC add with carry' ]
[ 'cccc 0010 110S nnnn dddd ssss mmmm mmmm |SBC subtract with carry' ]
[ 'cccc 0010 111S nnnn dddd ssss mmmm mmmm |RSC reverse subtract with carry' ]

[ 'cccc 010p ubwl nnnn dddd oooo oooo oooo |LDR / STR i = 0' ]
[ 'cccc 011p ubwl nnnn dddd ssss stt0 mmmm |LDR / STR i = 1' ]

[ 'cccc 0011 0p10 fsxc 1111 ssss mmmm mmmm |MSR imm' ]
[ 'cccc 0011 0001 nnnn dddd ssss mmmm mmmm |TST test bits (dddd is either all 0s or 1s)' ]
[ 'cccc 0011 0011 nnnn dddd ssss mmmm mmmm |TEQ test bitwise equality (dddd is either all 0s or 1s)' ]
[ 'cccc 0011 100S nnnn dddd ssss mmmm mmmm |ORR or' ]
[ 'cccc 0011 101S 0000 dddd ssss mmmm mmmm |MOV move register or constant' ]
[ 'cccc 0011 0101 nnnn dddd ssss mmmm mmmm |CMP compare (dddd is either all 0s or 1s)' ]
[ 'cccc 0011 110S nnnn dddd ssss mmmm mmmm |BIC bit clear' ]
[ 'cccc 0011 111S 0000 dddd ssss mmmm mmmm |MVN move negative register' ]
[ 'cccc 0011 0111 nnnn dddd ssss mmmm mmmm |CMN compare negative (dddd is either all 0s or 1s)' ]

[ 'cccc 100p uswl nnnn rrrr rrrr rrrr rrrr |LDM, STM', ]
[ 'cccc 101L oooo oooo oooo oooo oooo oooo |BRANCH / BRANCH AND LINK', ]
[ 'cccc 110p unwo nnnn dddd pppp mmmm mmmm |LDC / STC', ]
[ 'cccc 1110 oooo nnnn dddd pppp iii0 mmmm |CDP', ]
[ 'cccc 1110 oooa nnnn dddd pppp iii1 mmmm |MRC / MCR', ]
[ 'cccc 1111 xxxx xxxx xxxx xxxx xxxx xxxx |SOFTWARE INTERRUPT', ]



__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________THUMB_PARSING___________________________________________________________
__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________
=======
n - comment field for exception handler 
>>>>>>> parent of 5e5d75a... update instructions.txt
